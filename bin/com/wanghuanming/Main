package com.wanghuanming

import scala.Array.canBuildFrom
import scala.collection.mutable.Set

import org.apache.spark.SparkContext
import org.apache.spark.SparkContext.rddToPairRDDFunctions
import org.apache.spark.rdd.RDD

object Main{
  val smallFile = "10000"
  val bigFile =  "input/apriori_data.bat"

  //init 
  val sc = new SparkContext("yarn-cluster", "ming-FIM")
  val input = sc.textFile(bigFile)
  val limit = (input.count() * 0.85).toInt
  val transactions = input.map(line => (line.split(" ").map(_.toInt), 1)).reduceByKey(_ + _).cache


  def isCandidate(first: Set[Int], second: Set[Int], keySet: Array[Set[Int]]): Boolean = {
    (keySet.contains(first &~ second)) && ((first & second).size == first.size - 1)
  }

  def generateKeys(FIS: RDD[(Set[Int], Int)]): Array[Set[Int]] = {
    FIS.map(_._1).collect()
  }
  def generateCandidate(keys: Array[Set[Int]]) = {
    var candidate = scala.collection.mutable.Set[Set[Int]]()
    for (i <- keys) {
      for (j <- keys) {
        if (isCandidate(i, j, keys)) {
          candidate += (i ++ j)
        }
      }
    }
    candidate
  }
  def support(array: Array[Int], set: Set[Int]): Int = {
    var contain = 1
    set.find(item => {
        if (!array.contains(item)) {
          contain = 0
          true
        }
        else
          false
      })
    contain
  }

  def validateCandidate(candidate: Set[Set[Int]]) = {
    transactions.flatMap(line => {
        var tmp = scala.collection.mutable.Set[(Set[Int], Int)]()
        for (i <- candidate) {
          tmp += i -> support(line._1, i) * line._2
        }
        tmp
      }).reduceByKey(_ + _).filter(_._2 > limit)
  }


  def main(args: Array[String]) {
    //1 FIS
    var oneFIS = transactions.flatMap(line => line._1.map((_, line._2))).reduceByKey(_ + _).filter(_._2 > limit)
    oneFIS.saveAsTextFile("1FIS")

    // 2 FIS
    val keySet = oneFIS.map(_._1).collect()
    var candidate = Set[Set[Int]]()
    for (i <- keySet) {
      for (j <- keySet) {
        candidate += Set(i, j)
      }
    }
    val twoFIS = validateCandidate(candidate)

    twoFIS.saveAsTextFile("2FIS")

    // 3 FIS
    val keys2 = generateKeys(twoFIS)
    val threeFIS = validateCandidate(generateCandidate(keys2))

    threeFIS.saveAsTextFile("3FIS")

    //4 FIS
    val keys3 = generateKeys(threeFIS)
    val fourFIS = validateCandidate(generateCandidate(keys3))

    fourFIS.saveAsTextFile("4FIS")
    
    //5 FIS
    val fiveFIS = validateCandidate(generateCandidate(generateKeys(fourFIS)))
    fiveFIS.saveAsTextFile("5FIS")

  }
}
